/**
 * SEO Optimizer Module
 *
 * Comprehensive SEO optimization for generated websites:
 * - Technical SEO files (robots.txt, sitemap.xml)
 * - Structured data (JSON-LD schemas)
 * - Meta tag optimization
 * - Performance hints
 * - Accessibility checks
 */

// ============================================
// SEO CONFIGURATION
// ============================================

export interface SEOConfig {
  domain: string;
  siteName: string;
  defaultLanguage: string;
  socialProfiles?: {
    twitter?: string;
    facebook?: string;
    instagram?: string;
    linkedin?: string;
  };
  analytics?: {
    googleAnalyticsId?: string;
    googleTagManagerId?: string;
    facebookPixelId?: string;
  };
}

// ============================================
// STRUCTURED DATA GENERATORS
// ============================================

export interface OrganizationSchema {
  "@context": "https://schema.org";
  "@type": "Organization";
  name: string;
  url: string;
  logo?: string;
  description?: string;
  address?: {
    "@type": "PostalAddress";
    streetAddress?: string;
    addressLocality?: string;
    addressRegion?: string;
    postalCode?: string;
    addressCountry?: string;
  };
  contactPoint?: {
    "@type": "ContactPoint";
    telephone?: string;
    email?: string;
    contactType?: string;
  };
  sameAs?: string[];
}

export interface WebSiteSchema {
  "@context": "https://schema.org";
  "@type": "WebSite";
  name: string;
  url: string;
  description?: string;
  potentialAction?: {
    "@type": "SearchAction";
    target: string;
    "query-input": string;
  };
}

export interface BreadcrumbSchema {
  "@context": "https://schema.org";
  "@type": "BreadcrumbList";
  itemListElement: {
    "@type": "ListItem";
    position: number;
    name: string;
    item?: string;
  }[];
}

export interface FAQPageSchema {
  "@context": "https://schema.org";
  "@type": "FAQPage";
  mainEntity: {
    "@type": "Question";
    name: string;
    acceptedAnswer: {
      "@type": "Answer";
      text: string;
    };
  }[];
}

export interface LocalBusinessSchema {
  "@context": "https://schema.org";
  "@type": "LocalBusiness";
  name: string;
  image?: string;
  url: string;
  telephone?: string;
  address?: {
    "@type": "PostalAddress";
    streetAddress?: string;
    addressLocality?: string;
    addressRegion?: string;
    postalCode?: string;
    addressCountry?: string;
  };
  geo?: {
    "@type": "GeoCoordinates";
    latitude?: number;
    longitude?: number;
  };
  openingHoursSpecification?: {
    "@type": "OpeningHoursSpecification";
    dayOfWeek: string[];
    opens: string;
    closes: string;
  }[];
  priceRange?: string;
}

// ============================================
// SEO FILE GENERATORS
// ============================================

export function generateRobotsTxt(config: SEOConfig, disallowPaths: string[] = []): string {
  const lines = [
    "# Robots.txt for " + config.siteName,
    "# Generated by Prosektor Pipeline",
    "",
    "User-agent: *",
    "Allow: /",
    "",
    ...disallowPaths.map(path => `Disallow: ${path}`),
    "",
    `Sitemap: https://${config.domain}/sitemap.xml`,
    "",
    "# Crawl-delay for respectful crawling",
    "Crawl-delay: 1",
    "",
    "# Block AI training bots (optional)",
    "User-agent: GPTBot",
    "Disallow: /",
    "",
    "User-agent: ChatGPT-User",
    "Disallow: /",
    "",
    "User-agent: CCBot",
    "Disallow: /",
  ];

  return lines.join("\n");
}

export function generateSitemapXml(
  config: SEOConfig,
  pages: { url: string; lastmod?: string; changefreq?: string; priority?: number }[]
): string {
  const urlEntries = pages.map(page => `
  <url>
    <loc>https://${config.domain}${page.url}</loc>
    <lastmod>${page.lastmod || new Date().toISOString().split('T')[0]}</lastmod>
    <changefreq>${page.changefreq || 'weekly'}</changefreq>
    <priority>${page.priority || 0.5}</priority>
  </url>`).join('');

  return `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"
        xmlns:image="http://www.google.com/schemas/sitemap-image/1.1">
${urlEntries}
</urlset>`;
}

export function generateManifestJson(config: SEOConfig, colors: { primary: string; background: string }): object {
  return {
    name: config.siteName,
    short_name: config.siteName.substring(0, 12),
    description: `${config.siteName} web sitesi`,
    start_url: "/",
    display: "standalone",
    background_color: colors.background,
    theme_color: colors.primary,
    icons: [
      { src: "/icons/icon-72x72.png", sizes: "72x72", type: "image/png" },
      { src: "/icons/icon-96x96.png", sizes: "96x96", type: "image/png" },
      { src: "/icons/icon-128x128.png", sizes: "128x128", type: "image/png" },
      { src: "/icons/icon-144x144.png", sizes: "144x144", type: "image/png" },
      { src: "/icons/icon-152x152.png", sizes: "152x152", type: "image/png" },
      { src: "/icons/icon-192x192.png", sizes: "192x192", type: "image/png" },
      { src: "/icons/icon-384x384.png", sizes: "384x384", type: "image/png" },
      { src: "/icons/icon-512x512.png", sizes: "512x512", type: "image/png" },
    ],
  };
}

// ============================================
// META TAG GENERATORS
// ============================================

export interface MetaTags {
  title: string;
  description: string;
  keywords: string[];
  canonical: string;
  ogTitle?: string;
  ogDescription?: string;
  ogImage?: string;
  ogType?: string;
  twitterCard?: string;
  twitterTitle?: string;
  twitterDescription?: string;
  twitterImage?: string;
  robots?: string;
  author?: string;
  language?: string;
}

export function generateMetaTags(meta: MetaTags): string {
  const tags = [
    `<title>${meta.title}</title>`,
    `<meta name="description" content="${meta.description}" />`,
    `<meta name="keywords" content="${meta.keywords.join(', ')}" />`,
    `<link rel="canonical" href="${meta.canonical}" />`,
    "",
    "<!-- Open Graph -->",
    `<meta property="og:title" content="${meta.ogTitle || meta.title}" />`,
    `<meta property="og:description" content="${meta.ogDescription || meta.description}" />`,
    `<meta property="og:type" content="${meta.ogType || 'website'}" />`,
    `<meta property="og:url" content="${meta.canonical}" />`,
    meta.ogImage ? `<meta property="og:image" content="${meta.ogImage}" />` : "",
    "",
    "<!-- Twitter Card -->",
    `<meta name="twitter:card" content="${meta.twitterCard || 'summary_large_image'}" />`,
    `<meta name="twitter:title" content="${meta.twitterTitle || meta.title}" />`,
    `<meta name="twitter:description" content="${meta.twitterDescription || meta.description}" />`,
    meta.twitterImage ? `<meta name="twitter:image" content="${meta.twitterImage}" />` : "",
    "",
    "<!-- Additional -->",
    `<meta name="robots" content="${meta.robots || 'index, follow'}" />`,
    meta.author ? `<meta name="author" content="${meta.author}" />` : "",
    `<meta name="language" content="${meta.language || 'tr'}" />`,
    `<meta http-equiv="content-language" content="${meta.language || 'tr'}" />`,
  ].filter(Boolean);

  return tags.join("\n");
}

// ============================================
// SEO CHECKS & SCORING
// ============================================

export interface SEOCheck {
  id: string;
  category: "technical" | "content" | "performance" | "mobile" | "social";
  name: string;
  status: "pass" | "warning" | "fail";
  score: number; // 0-100
  message: string;
  recommendation?: string;
}

export interface SEOAuditResult {
  overallScore: number;
  checks: SEOCheck[];
  passedCount: number;
  warningCount: number;
  failedCount: number;
  recommendations: string[];
}

export function runSEOAudit(
  content: {
    title: string;
    description: string;
    headings: { level: number; text: string }[];
    images: { src: string; alt?: string }[];
    links: { href: string; text: string; isExternal: boolean }[];
    wordCount: number;
  },
  config: SEOConfig
): SEOAuditResult {
  const checks: SEOCheck[] = [];

  // Title checks
  const titleLength = content.title.length;
  checks.push({
    id: "title-length",
    category: "content",
    name: "Baslik Uzunlugu",
    status: titleLength >= 30 && titleLength <= 60 ? "pass" : titleLength >= 20 && titleLength <= 70 ? "warning" : "fail",
    score: titleLength >= 30 && titleLength <= 60 ? 100 : titleLength >= 20 && titleLength <= 70 ? 70 : 30,
    message: `Baslik ${titleLength} karakter (ideal: 30-60)`,
    recommendation: titleLength < 30 ? "Basligi uzatin" : titleLength > 60 ? "Basligi kisaltin" : undefined,
  });

  // Description checks
  const descLength = content.description.length;
  checks.push({
    id: "description-length",
    category: "content",
    name: "Meta Description Uzunlugu",
    status: descLength >= 120 && descLength <= 160 ? "pass" : descLength >= 80 && descLength <= 200 ? "warning" : "fail",
    score: descLength >= 120 && descLength <= 160 ? 100 : descLength >= 80 && descLength <= 200 ? 70 : 30,
    message: `Description ${descLength} karakter (ideal: 120-160)`,
    recommendation: descLength < 120 ? "Description uzatin" : descLength > 160 ? "Description kisaltin" : undefined,
  });

  // H1 check
  const h1Count = content.headings.filter(h => h.level === 1).length;
  checks.push({
    id: "h1-count",
    category: "content",
    name: "H1 Basligi",
    status: h1Count === 1 ? "pass" : h1Count === 0 ? "fail" : "warning",
    score: h1Count === 1 ? 100 : h1Count === 0 ? 0 : 50,
    message: `Sayfada ${h1Count} adet H1 basligi var (ideal: 1)`,
    recommendation: h1Count === 0 ? "H1 basligi ekleyin" : h1Count > 1 ? "Tek H1 kullanin" : undefined,
  });

  // Heading hierarchy
  const headingLevels = content.headings.map(h => h.level);
  const hasProperHierarchy = headingLevels.every((level, i) => i === 0 || level <= headingLevels[i - 1] + 1);
  checks.push({
    id: "heading-hierarchy",
    category: "content",
    name: "Baslik Hiyerarsisi",
    status: hasProperHierarchy ? "pass" : "warning",
    score: hasProperHierarchy ? 100 : 60,
    message: hasProperHierarchy ? "Baslik hiyerarsisi dogru" : "Baslik siralama sorunu var",
    recommendation: hasProperHierarchy ? undefined : "H1 > H2 > H3 sirasiyla kullanin",
  });

  // Image alt text
  const imagesWithoutAlt = content.images.filter(img => !img.alt || img.alt.trim() === "");
  checks.push({
    id: "image-alt",
    category: "content",
    name: "Gorsel Alt Metinleri",
    status: imagesWithoutAlt.length === 0 ? "pass" : imagesWithoutAlt.length <= 2 ? "warning" : "fail",
    score: content.images.length === 0 ? 100 : Math.round(((content.images.length - imagesWithoutAlt.length) / content.images.length) * 100),
    message: `${content.images.length} gorselden ${imagesWithoutAlt.length} tanesi alt metin icermiyor`,
    recommendation: imagesWithoutAlt.length > 0 ? "Tum gorsellere alt metin ekleyin" : undefined,
  });

  // Word count
  checks.push({
    id: "word-count",
    category: "content",
    name: "Icerik Uzunlugu",
    status: content.wordCount >= 300 ? "pass" : content.wordCount >= 150 ? "warning" : "fail",
    score: content.wordCount >= 500 ? 100 : content.wordCount >= 300 ? 80 : content.wordCount >= 150 ? 50 : 20,
    message: `Sayfa ${content.wordCount} kelime iceriyor (min. 300 onerilir)`,
    recommendation: content.wordCount < 300 ? "Daha fazla icerik ekleyin" : undefined,
  });

  // Internal links
  const internalLinks = content.links.filter(l => !l.isExternal);
  checks.push({
    id: "internal-links",
    category: "technical",
    name: "Ic Baglanti Sayisi",
    status: internalLinks.length >= 3 ? "pass" : internalLinks.length >= 1 ? "warning" : "fail",
    score: internalLinks.length >= 3 ? 100 : internalLinks.length >= 1 ? 60 : 20,
    message: `${internalLinks.length} adet ic baglanti var`,
    recommendation: internalLinks.length < 3 ? "Daha fazla ic baglanti ekleyin" : undefined,
  });

  // Calculate overall score
  const overallScore = Math.round(checks.reduce((sum, check) => sum + check.score, 0) / checks.length);
  const passedCount = checks.filter(c => c.status === "pass").length;
  const warningCount = checks.filter(c => c.status === "warning").length;
  const failedCount = checks.filter(c => c.status === "fail").length;
  const recommendations = checks.filter(c => c.recommendation).map(c => c.recommendation!);

  return {
    overallScore,
    checks,
    passedCount,
    warningCount,
    failedCount,
    recommendations,
  };
}

// ============================================
// SEO OPTIMIZATION SUGGESTIONS
// ============================================

export function generateSEOSuggestions(
  industry: string,
  targetAudience: string[],
  competitors: string[]
): {
  keywords: string[];
  contentTopics: string[];
  backlinkOpportunities: string[];
  localSEOTips: string[];
} {
  // This would typically use AI to generate industry-specific suggestions
  return {
    keywords: [
      `${industry} hizmetleri`,
      `en iyi ${industry}`,
      `${industry} fiyatlari`,
      `${industry} yorumlari`,
      `profesyonel ${industry}`,
    ],
    contentTopics: [
      `${industry} Sektorunde 2024 Trendleri`,
      `${industry} Hizmetlerinde Nelere Dikkat Edilmeli?`,
      `${industry} Firmalari Nasil Secilir?`,
      `${industry} Maliyetleri ve Fiyatlandirma`,
    ],
    backlinkOpportunities: [
      "Sektor dernekleri ve birlikleri",
      "Yerel is rehberleri",
      "Musterilerin web siteleri",
      "Tedarikci firmalarin partner sayfalari",
    ],
    localSEOTips: [
      "Google My Business profilinizi guncelleyin",
      "Yerel dizinlere kayit olun",
      "Musteri yorumlari isteyin",
      "Yerel etkinliklere sponsor olun",
    ],
  };
}
